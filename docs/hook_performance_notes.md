# Hook评论发送性能与限制说明

> **补充文档**：请将此内容合并到`moments_rush_guide.md`第3节后
> 创建时间：2026-02-12

## 3.5. Hook 性能与限制

### 当前工作模式：Serial Mode

**配置要求**：
```python
dispatcher = CommentDispatcher(
    hook_bridge=bridge,
    max_concurrency=1,  # ⚠️ 必须为1，不可修改
    piggyback_timeout_ms=30000
)
```

### 性能数据

**实测性能**（基于3轮×10条评论测试）：

| 指标 | 数值 |
|------|------|
| 单条评论平均耗时 | ~755ms |
| 10条评论总耗时 | ~7.8秒 |
| P95延迟 | 7745ms |
| 成功率 | 100% (30/30) |
| 稳定性 | ✅ 完全稳定 |

**时间分解**（10条评论）：
- UI触发：~2.5-3秒
- Hook串行发送9条：~5秒
- **总计**：~7.8秒

**与纯UI对比**：
- 纯UI自动化：~3秒/条 × 10 = **30秒**
- Serial Mode：**7.8秒**
- **加速比**：**3.8×**

### 并发限制说明

**❌ 不支持并发执行**（concurrency >= 2）

**原因**：微信内部`cgi_A_caller_2`函数**不是线程安全**的，并发调用会导致DLL崩溃。

**已尝试的解决方案**：
1. ❌ TLS override - 崩溃
2. ❌ TLS accessor加锁 - 崩溃
3. ❌ 仅依赖arg1 patch - 崩溃
4. ✅ Serial Mode (concurrency=1) - 稳定

**详细调查报告**：`docs/hook_parallel_investigation_2026-02-12.md`

### 工作流程

```
用户触发抢答
    ↓
1. UI自动化发送第1条评论（耗时~3秒）
    ↓
2. 触发hook回调，捕获运行时状态
    ↓
3. Hook在**同一回调中串行**发送剩余9条评论（耗时~5秒）
    ↓
4. 返回，总计~8秒
```

### 未来优化方向

如有强烈性能需求（目标<1秒/10条），可考虑：

1. **Hook底层网络函数**（推荐，中等难度）
   - 绕过业务层，直接Hook WSASend或protobuf层
   - 网络层可能支持并发
   - 预估工作量：2-3周

2. **复用微信内部线程池**（高难度）
   - 使用微信自己的worker线程发送
   - 理论上线程安全
   - 预估工作量：4-6周

3. **多轮UI触发**（低难度，低收益）
   - UI快速连续触发多次，每次hook串行发送少量
   - 总耗时不变甚至更长
   - 预估工作量：1-2天

### 推荐配置

**生产环境**：
```python
# 使用Serial Mode，稳定可靠
max_concurrency=1
piggyback_timeout_ms=30000  # 给足够的时间串行发送
```

**调试/实验**：
```python
# 如需测试并发（会崩溃）
max_concurrency=2  # ⚠️ 仅用于调试，生产禁用
```

**DLL配置**：
```cpp
// hook/src/sns_comment.cpp
bool g_tls_override_enabled = false;  // 保持默认禁用
```

### 常见问题

**Q: 为什么不能并发执行？**
A: 微信内部函数不是线程安全的，多线程并发调用会导致崩溃。这是微信代码限制，不是Hook实现问题。

**Q: 8秒/10条够用吗？**
A: 对于朋友圈抢答场景，8秒已经远快于手动输入或纯UI自动化（30秒）。如果需要更快，需要深度逆向分析网络层（工作量大）。

**Q: 能否通过提升微信版本解决？**
A: 不确定。线程安全通常是设计层面的决策，微信小版本升级不太可能改变。需要每个版本重新测试。

**Q: 会影响微信账号安全吗？**
A: Serial Mode使用与正常评论相同的调用路径，仅在速度上快于手动。理论风险与纯UI自动化相当。建议合理使用，避免短时间大量评论。
